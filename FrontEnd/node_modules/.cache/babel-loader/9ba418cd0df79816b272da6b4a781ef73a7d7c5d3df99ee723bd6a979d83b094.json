{"ast":null,"code":"import { useRef, useEffect } from 'react';\nimport { AnimationType } from '../../../render/utils/types.mjs';\nimport { warnOnce } from '../../../utils/warn-once.mjs';\nimport { observeIntersection } from './observers.mjs';\nfunction useViewport(_ref) {\n  let {\n    visualElement,\n    whileInView,\n    onViewportEnter,\n    onViewportLeave,\n    viewport = {}\n  } = _ref;\n  const state = useRef({\n    hasEnteredView: false,\n    isInView: false\n  });\n  let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n  if (viewport.once && state.current.hasEnteredView) shouldObserve = false;\n  const useObserver = typeof IntersectionObserver === \"undefined\" ? useMissingIntersectionObserver : useIntersectionObserver;\n  useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nconst thresholdNames = {\n  some: 0,\n  all: 1\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, _ref2) {\n  let {\n    root,\n    margin: rootMargin,\n    amount = \"some\",\n    once\n  } = _ref2;\n  useEffect(() => {\n    if (!shouldObserve || !visualElement.current) return;\n    const options = {\n      root: root === null || root === void 0 ? void 0 : root.current,\n      rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    const intersectionCallback = entry => {\n      const {\n        isIntersecting\n      } = entry;\n      /**\r\n       * If there's been no change in the viewport state, early return.\r\n       */\n      if (state.isInView === isIntersecting) return;\n      state.isInView = isIntersecting;\n      /**\r\n       * Handle hasEnteredView. If this is only meant to run once, and\r\n       * element isn't visible, early return. Otherwise set hasEnteredView to true.\r\n       */\n      if (once && !isIntersecting && state.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        state.hasEnteredView = true;\n      }\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, isIntersecting);\n      }\n      /**\r\n       * Use the latest committed props rather than the ones in scope\r\n       * when this observer is created\r\n       */\n      const props = visualElement.getProps();\n      const callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(visualElement.current, options, intersectionCallback);\n  }, [shouldObserve, root, rootMargin, amount]);\n}\n/**\r\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\r\n * on mount. This way, the page will be in the state the author expects users\r\n * to see it in for everyone.\r\n */\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, _ref3) {\n  let {\n    fallback = true\n  } = _ref3;\n  useEffect(() => {\n    if (!shouldObserve || !fallback) return;\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n    }\n    /**\r\n     * Fire this in an rAF because, at this point, the animation state\r\n     * won't have flushed for the first time and there's certain logic in\r\n     * there that behaves differently on the initial animation.\r\n     *\r\n     * This hook should be quite rarely called so setting this in an rAF\r\n     * is preferred to changing the behaviour of the animation state.\r\n     */\n    requestAnimationFrame(() => {\n      state.hasEnteredView = true;\n      const {\n        onViewportEnter\n      } = visualElement.getProps();\n      onViewportEnter && onViewportEnter(null);\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, true);\n      }\n    });\n  }, [shouldObserve]);\n}\nexport { useViewport };","map":{"version":3,"names":["useRef","useEffect","AnimationType","warnOnce","observeIntersection","useViewport","visualElement","whileInView","onViewportEnter","onViewportLeave","viewport","state","hasEnteredView","isInView","shouldObserve","Boolean","once","current","useObserver","IntersectionObserver","useMissingIntersectionObserver","useIntersectionObserver","thresholdNames","some","all","root","margin","rootMargin","amount","options","threshold","intersectionCallback","entry","isIntersecting","animationState","setActive","InView","props","getProps","callback","fallback","process","env","NODE_ENV","requestAnimationFrame"],"sources":["F:/fyp/Ecommerce-Virtual-Reality-based-Web-Application/FrontEnd/node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs"],"sourcesContent":["import { useRef, useEffect } from 'react';\r\nimport { AnimationType } from '../../../render/utils/types.mjs';\r\nimport { warnOnce } from '../../../utils/warn-once.mjs';\r\nimport { observeIntersection } from './observers.mjs';\r\n\r\nfunction useViewport({ visualElement, whileInView, onViewportEnter, onViewportLeave, viewport = {}, }) {\r\n    const state = useRef({\r\n        hasEnteredView: false,\r\n        isInView: false,\r\n    });\r\n    let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\r\n    if (viewport.once && state.current.hasEnteredView)\r\n        shouldObserve = false;\r\n    const useObserver = typeof IntersectionObserver === \"undefined\"\r\n        ? useMissingIntersectionObserver\r\n        : useIntersectionObserver;\r\n    useObserver(shouldObserve, state.current, visualElement, viewport);\r\n}\r\nconst thresholdNames = {\r\n    some: 0,\r\n    all: 1,\r\n};\r\nfunction useIntersectionObserver(shouldObserve, state, visualElement, { root, margin: rootMargin, amount = \"some\", once }) {\r\n    useEffect(() => {\r\n        if (!shouldObserve || !visualElement.current)\r\n            return;\r\n        const options = {\r\n            root: root === null || root === void 0 ? void 0 : root.current,\r\n            rootMargin,\r\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\r\n        };\r\n        const intersectionCallback = (entry) => {\r\n            const { isIntersecting } = entry;\r\n            /**\r\n             * If there's been no change in the viewport state, early return.\r\n             */\r\n            if (state.isInView === isIntersecting)\r\n                return;\r\n            state.isInView = isIntersecting;\r\n            /**\r\n             * Handle hasEnteredView. If this is only meant to run once, and\r\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\r\n             */\r\n            if (once && !isIntersecting && state.hasEnteredView) {\r\n                return;\r\n            }\r\n            else if (isIntersecting) {\r\n                state.hasEnteredView = true;\r\n            }\r\n            if (visualElement.animationState) {\r\n                visualElement.animationState.setActive(AnimationType.InView, isIntersecting);\r\n            }\r\n            /**\r\n             * Use the latest committed props rather than the ones in scope\r\n             * when this observer is created\r\n             */\r\n            const props = visualElement.getProps();\r\n            const callback = isIntersecting\r\n                ? props.onViewportEnter\r\n                : props.onViewportLeave;\r\n            callback && callback(entry);\r\n        };\r\n        return observeIntersection(visualElement.current, options, intersectionCallback);\r\n    }, [shouldObserve, root, rootMargin, amount]);\r\n}\r\n/**\r\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\r\n * on mount. This way, the page will be in the state the author expects users\r\n * to see it in for everyone.\r\n */\r\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, { fallback = true }) {\r\n    useEffect(() => {\r\n        if (!shouldObserve || !fallback)\r\n            return;\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\r\n        }\r\n        /**\r\n         * Fire this in an rAF because, at this point, the animation state\r\n         * won't have flushed for the first time and there's certain logic in\r\n         * there that behaves differently on the initial animation.\r\n         *\r\n         * This hook should be quite rarely called so setting this in an rAF\r\n         * is preferred to changing the behaviour of the animation state.\r\n         */\r\n        requestAnimationFrame(() => {\r\n            state.hasEnteredView = true;\r\n            const { onViewportEnter } = visualElement.getProps();\r\n            onViewportEnter && onViewportEnter(null);\r\n            if (visualElement.animationState) {\r\n                visualElement.animationState.setActive(AnimationType.InView, true);\r\n            }\r\n        });\r\n    }, [shouldObserve]);\r\n}\r\n\r\nexport { useViewport };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}